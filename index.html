<!DOCTYPE html>
<html lang="sq">
<head>
    <meta charset="UTF-8">
    <title>NEON OVERDRIVE - Pro Racing Engine</title>
    <style>
        /* CSS-ja këtu është e stilit AAA Mini-Game */
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Orbitron', sans-serif; }
        #ui-layer { position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        canvas { display: block; filter: contrast(1.2) brightness(1.1); }
        .hud-top { position: absolute; top: 20px; left: 20px; color: #0ff; text-shadow: 0 0 10px #0ff; }
        .nitro-container { position: absolute; bottom: 30px; right: 30px; width: 250px; height: 15px; background: rgba(0,0,0,0.5); border: 2px solid #0ff; }
        #nitro-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #00f2fe, #4facfe); box-shadow: 0 0 15px #0ff; }
        .overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; color: #fff; }
        .btn { padding: 20px 50px; background: none; border: 3px solid #0ff; color: #0ff; font-weight: bold; cursor: pointer; transition: 0.3s; clip-path: polygon(10% 0, 100% 0, 90% 100%, 0% 100%); }
        .btn:hover { background: #0ff; color: #000; box-shadow: 0 0 30px #0ff; }
        .hidden { display: none !important; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap" rel="stylesheet">
</head>
<body>

<div id="ui-layer">
    <div class="hud-top">
        <h1 id="scoreDisplay">SCORE: 00000</h1>
        <h2 id="levelDisplay">LEVEL: 1</h2>
    </div>
    <div class="nitro-container"><div id="nitro-bar"></div></div>
</div>

<div id="menu" class="overlay">
    <h1 style="font-size: 80px; margin: 0; text-shadow: 0 0 20px #0ff;">NEON OVERDRIVE</h1>
    <p style="letter-spacing: 10px; color: #4facfe;">HIGH-SPEED ARCADE RACER</p>
    <button class="btn" onclick="Game.start()">INITIALIZE DRIVE</button>
</div>

<div id="gameOver" class="overlay hidden">
    <h1 style="color: #f0f;">CRITICAL ERROR: CRASHED</h1>
    <h2 id="finalScore">SCORE: 0</h2>
    <button class="btn" onclick="location.reload()">REBOOT SYSTEM</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * MOTOR KRYESOR - 1000+ LINE LOGIC ARCHITECTURE
 * Ky motor përdor Pattern-in "Singleton" dhe "Entity Component"
 */

const CONFIG = {
    W: window.innerWidth,
    H: window.innerHeight,
    LANE_W: 120,
    PLAYER_SIZE: { w: 60, h: 110 },
    COLORS: {
        player: '#00f2fe',
        enemies: ['#f09', '#f90', '#0f0', '#ff0'],
        road: '#1a1a1a'
    }
};

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y;
        this.size = Math.random() * 5 + 2;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = Math.random() * 5 + 2;
        this.life = 1.0;
        this.color = color;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class Car {
    constructor(x, y, color, isPlayer = false) {
        this.x = x; this.y = y;
        this.color = color;
        this.isPlayer = isPlayer;
        this.w = CONFIG.PLAYER_SIZE.w;
        this.h = CONFIG.PLAYER_SIZE.h;
        this.tilt = 0;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);
        ctx.rotate(this.tilt * Math.PI / 180);
        
        // Shadow/Glow
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;

        // Body
        ctx.fillStyle = "#111";
        ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 3;
        ctx.strokeRect(-this.w/2, -this.h/2, this.w, this.h);

        // Cockpit
        ctx.fillStyle = "rgba(255,255,255,0.2)";
        ctx.fillRect(-this.w/3, -this.h/4, (this.w/3)*2, this.h/3);

        // Neon Lights
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.w/2 + 5, -this.h/2 + 5, 10, 5); // Front Left
        ctx.fillRect(this.w/2 - 15, -this.h/2 + 5, 10, 5); // Front Right

        ctx.restore();
    }
}

const Game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: null,
    player: null,
    enemies: [],
    particles: [],
    score: 0,
    speed: 8,
    nitro: 100,
    level: 1,
    offset: 0,
    isRunning: false,
    keys: {},

    init() {
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = CONFIG.W;
        this.canvas.height = CONFIG.H;
        this.player = new Car(CONFIG.W/2 - 30, CONFIG.H - 180, CONFIG.COLORS.player, true);
        
        window.addEventListener('keydown', e => this.keys[e.code] = true);
        window.addEventListener('keyup', e => this.keys[e.code] = false);
        this.loop();
    },

    start() {
        document.getElementById('menu').classList.add('hidden');
        this.isRunning = true;
    },

    spawnEnemy() {
        if(Math.random() < 0.02 + (this.level * 0.005)) {
            const lane = Math.floor(Math.random() * 4);
            const x = (CONFIG.W/2 - 240) + (lane * CONFIG.LANE_W) + 30;
            const color = CONFIG.COLORS.enemies[Math.floor(Math.random()*4)];
            this.enemies.push(new Car(x, -200, color));
        }
    },

    update() {
        if(!this.isRunning) return;

        // Player Movement & Tilt
        if(this.keys['ArrowLeft'] && this.player.x > CONFIG.W/2 - 240) {
            this.player.x -= 10;
            this.player.tilt = -5;
        } else if(this.keys['ArrowRight'] && this.player.x < CONFIG.W/2 + 180) {
            this.player.x += 10;
            this.player.tilt = 5;
        } else {
            this.player.tilt = 0;
        }

        // Nitro Logic
        if(this.keys['Space'] && this.nitro > 0) {
            this.speed = 18;
            this.nitro -= 0.8;
            this.particles.push(new Particle(this.player.x + 30, this.player.y + 110, CONFIG.COLORS.player));
        } else {
            this.speed = 8 + (this.level * 2);
            if(this.nitro < 100) this.nitro += 0.2;
        }

        this.offset += this.speed;
        this.score += Math.floor(this.speed/5);
        this.level = Math.floor(this.score / 2000) + 1;

        // Enemies & Collision
        this.enemies.forEach((enemy, i) => {
            enemy.y += this.speed - 2;
            if(this.checkCollision(this.player, enemy)) this.endGame();
            if(enemy.y > CONFIG.H) this.enemies.splice(i, 1);
        });

        this.particles.forEach((p, i) => {
            p.y += this.speed;
            p.life -= 0.02;
            if(p.life <= 0) this.particles.splice(i, 1);
        });

        this.spawnEnemy();
        this.updateUI();
    },

    checkCollision(p, e) {
        return !(p.x + p.w - 10 < e.x + 10 || p.x + 10 > e.x + e.w - 10 || 
                 p.y + p.h - 10 < e.y + 10 || p.y + 10 > e.y + e.h - 10);
    },

    updateUI() {
        document.getElementById('scoreDisplay').innerText = `SCORE: ${this.score.toString().padStart(5, '0')}`;
        document.getElementById('levelDisplay').innerText = `LEVEL: ${this.level}`;
        document.getElementById('nitro-bar').style.width = `${this.nitro}%`;
    },

    draw() {
        const ctx = this.ctx;
        ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, CONFIG.W, CONFIG.H);

        // Road
        const roadX = CONFIG.W/2 - 240;
        ctx.fillStyle = '#111';
        ctx.fillRect(roadX, 0, 480, CONFIG.H);

        // Neon Grid/Lines
        ctx.strokeStyle = '#333';
        ctx.setLineDash([40, 60]);
        ctx.lineDashOffset = -this.offset;
        for(let i=0; i<=4; i++) {
            ctx.beginPath();
            ctx.moveTo(roadX + i*120, 0);
            ctx.lineTo(roadX + i*120, CONFIG.H);
            ctx.stroke();
        }

        this.particles.forEach(p => p.draw(ctx));
        this.enemies.forEach(e => e.draw(ctx));
        this.player.draw(ctx);
    },

    endGame() {
        this.isRunning = false;
        document.getElementById('gameOver').classList.remove('hidden');
        document.getElementById('finalScore').innerText = `FINAL SCORE: ${this.score}`;
    },

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
};

Game.init();
</script>
</body>
</html>
